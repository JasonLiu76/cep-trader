#summary Overall Documentation of the Framework AlgoTrader as well as instructions on how to build a strategy with it

<wiki:toc max_depth="2" />

= Introduction =

The Trading Framework AlgoTrader facilitates a minimum effort development of trading strategies based on Esper Query Language (EQL).

After backtesting, newly developed strategies can be tested in a live environment using Paper Trading Accounts. At the end of a thorough test procedure, the new strategy can be put into production. The following diagram shows the general procedure for developing new strategies:

http://cep-trader.googlecode.com/files/AlgoTrader-Strategy_Development_Process.gif

The system is developed by a Model Driven Architecture. All artifacts of the system are modeled in UML and generated into code by the [http://www.andromda.org/docs/index.html Framework AndroMDA].
The system does not provide a GUI Frontend. Instead it uses Java Management Extension (JMX) for management in runtime.

For Database Persistence the [http://www.hibernate.org/ Framework Hibernate] is used. All necessary information is recorded to the database in a statefull manner.

The system is also based on the Java Enterprise Framework [http://www.springsource.org/ Springframework], which enables a very clean Service Oriented Architecture.

= Architecture =

The System is basically composed of two layers.

The Trading Framework layer is the base for all strategies running on top of it. It is responsible for persistence to the database. It holds the connection to the Broker Interfaces to retrieve live market data as well as placing orders and tracking executions. The Trading Framework is also responsible for Risk Management, Portfolio Management, Performance Evaluation and Margining. For many of its tasks the Trading Framework uses a contained Esper Engine Instance.

On top of the Trading Framework any number of Strategies can be installed. Each strategy runs in its own process. Each Strategy contains its own Esper Engine Instance. A Strategy can use any type and number of Technical Indicators to evaluate trend and to retrieve market signals. Orders are delegated to the underlying Trading Framework for execution.

http://cep-trader.googlecode.com/files/AlgoTrader-Architecture_Layers.gif

= Platform requirements =

For development of new Strategies the following minimum Platform requirements exist:

|| *Software* || *URL* ||
|| Eclipse IDE || http://www.eclipse.org ||
|| Subversive SVN Client ||  http://www.eclipse.org/subversive ||
|| M2 Eclipse || http://m2eclipse.sonatype.org/sites/m2e/ || 
|| M2 Subversive || http://www.polarion.org/projects/subversive/download/integrations/update-site/ ||
|| MySql Database || http://www.mysql.com ||
|| A database management tool (i.e. TOAD for MySql) || http://www.quest.com/toad-for-mysql  || 
|| MagicDraw UML || http://nomagic.be/files95 (use MD_UML_95_sp1_CE... for your plattform) ||

<BR>
= Eclipse Projects =

The framework AlgoTrader consists of at least two Eclipse Projects:

 * AlgoTraderLight (the main project)
 * AlgoTraderLight-code (contains all java code)
 * AlgoTraderLight-mda (contains the UML Model and code generator)
 * AlgoTraderXXX (the strategy beeing developped)

AlgoTraderLight has the following structure:

|| *Directory* || *Description* ||
|| code/src || Contains manually created source files ||
|| code/target || Contains generated source files ||
|| code/results || Contains files which are created (i.e. copy of retrieved HTML code) or imported (i.e. Tick Data) into the system ||
|| code/log || Contains log files ||
|| mda/src || Contains UML Model and AndroMDA configuration / customization files||
|| mda/conf || Contains configuration files for the generator||
|| sql || Contains SQL scripts ||

The Strategy Project AlgoTraderXXX has the following structure:

|| *Directory* || *Description* ||
|| src || Contains manually created source files ||
|| lib || Contains Jar libraries specifically needed by the strategy||
|| bin || Contains startup batch files ||
|| log || Contains log files ||
|| results || Contains mainly Tick Data Files ||

<BR>
= UML Model =

The UML Model in use by the system is shown here: [http://cep-trader.googlecode.com/files/AlgoTrader%20UML%20Model.pdf UML Model]

= Java Packages =

The following table gives an overview of the provided java packages:

|| *Package* || *Description* ||
|| com.algoTrader || ServiceLocators ||
|| com.algoTrader.entity || Entities and corresponding Hibernate DataAccessObjects ||
|| com.algoTrader.service || Contains all Spring Services  ||
|| com.algoTrader.starter || Startup-Classes as well as a generic ServiceInvoker ||
|| com.algoTrader.subscriber || Esper Statement Subscribers ||
|| com.algoTrader.util || General Utility methods ||
|| com.algoTrader.util.io || CSV Adapters for Tick data as well as Tick data conversion functions ||

The application contains the following POJO-Entities:
 * Tick
 * Security
 * SecurityFamily (containing Security  Metadata)
 * Transaction
 * Position
 * Strategy
 * WatchListItem

The following SOA-Services provide the functionality of the system:
 * TickService (handling CSV-Files as well as Watchlist)
 * TransactionService(handling Orders and Executions)
 * PositionService (handling positions, Stop-Losses and Margin)
 * RuleService (Esper engine abstraction)
 * SimulationService (coordination of BackTesting)
 * LookupService (general lookup functionality)

= Esper Engine =

Individual Esper service engines exist inside the trading framework as well as within the strategies. 

Each of these can contain several modules. Modules specified with in the column Modules of the Table Strategy, are loaded automatically on startup.

Each strategy also contains its own Esper configuration file named esper-xxx.cfg.xml. These configuration files define settings like:

 * Event Types
 * Auto Import Classes & Packages
 * Custom Aggregation Functions
 * Variables
 * General Engine Settings

Esper Listeners and Subscribers are configured inside the modules using the following syntax:

{{{
@Name('REBALANCE_PORTFOLIO')
@Priority(2)
@Tag(name='listeners', value='com.algoTrader.listener.RebalancePortfolioListener')
select * from …
}}}

Listeners or Subscribers which correspond to a particular Service are commonly implemented as an inner class of the Service.

== Trading Framework Modules ==

The Trading Framework contains only one module called module-base.epl with Esper Statements to fulfill the following tasks:

 * Evaluation and Logging of the Portfolio Values at certain intervals
 * Position handling (i.e. close position when exit level is reached, etc.)
 * Evaluation of Performance Parameters (i.e. Sharpe Ratio, Calmar Ratio, Volatility, Draw-Down, etc.)
 * Margining

== Strategy Modules ==

Strategies are completely free in the definition of their Esper Statements. Examples of Statements used by strategies are:

 * Creation of technical indicators (i.e. Moving 
 * Average, Stochastic, MACD, etc.)
 * Creation of trade signals
 * Trend evaluation
 * Open / Close / Increase / Reduce Positions
 * Set Exit Values
 * Roll Positions (i.e. for Options and Futures)

= Database =

As described earlier the database MySql is used by the system, even though by using Hibernate, any supported database could be used.
 
To ensure referential integrity, foreign-key constraints are in place. The directory sql /AlgoTraderLight contains a script algotrader.sql to create the database.

= Installation =

== Subversion Checkout ==

It is recommended to use the Plugin M2Eclipse for this checkout (Import / Maven / Check out Maven Projects from SCM). 

Select https://cep-trader.googlecode.com/svn/trunk/AlgoTraderLight. This will create the following 3 projects in Eclipse:

 * AlgoTraderLight
 * AlgoTraderLight-code
 * AlgoTraderLight-mda

Run the import again and select https://cep-trader.googlecode.com/svn/trunk/AlgoTraderMov. This will create the following additional project in Eclipse:

 * AlgoTraderMov

== Generate the code ==
run mvn install inside the AlgoTrader-mda project. This will generate all necessary code into AlgoTrader-code target directory.

== Compile ==
run mvn install inside the AlgoTrader-code project. This will compile all class-files and install the jar-files into the local repository

== Install MySql ==
Install latest MySql from [http://www.mysql.com/downloads/mysql/ MySql]
 * create a schema named AlgoTrader
 * run the create-script: sql/algotrader.sql
 * configure the properties dataSource.user & dataSource.password inside src/conf-base.properties:


== Start the Demo Strategy ==
Run the class com.algoTrader.starter.SimulationStarter inside the project AlgoTraderMov. 
This class is part of AlgoTraderLight, but it has to be executed from AlgoTraderMov.
(the projet AlgoTraderMov has a dependency to AlgoTraderLight for this purpose)

If using Eclipse specify the following in the Launch Configuration:

Main-Tab:
 * Project: AlgoTraderMov
 * Main Class: com.algoTrader.starter.SimulationStarter
 
Arguments-Tab / VM-Arguments: 
 * -Dsimulation=true
 * -DdataSource.dataSet=1year 

= Strategy Development =

The following paragraph will give a short example based on a simple moving average strategy (with the Short Name MOV).

A strategy is based on the following minimum artifacts:

|| *Artifact* || *Description* ||
|| /src || Source-File Directory containing necessary Java-Classes for the Strategy ||
|| /lib || Directory containing Jar Files needed specifically for this Strategy ||
|| /module-mov.epl || Esper Module containing the necessary Esper Statements ||
|| /conf-mov.properties  || Contains parameters used by the strategy (i.e. Moving average durations etc.) ||
|| /esper-mov.cfg.xml || Contains event-types, imports, variables and general Esper settings ||
|| /beanRefFactorySimulation.xml || Spring Bean Reference Factory containing references to all Application Context Files ||
|| /applicationContext-mov.xml || Application Context File for the strategy, mainly containing autowire instructions ||
|| /results/tickdata/xxx || Directory containing Tick Data Files needed for Back Testing ||
|| DB table strategy || A record for the strategy ||

== MovServiceImpl.java ==

This is the main Java-class containing Subscriber inner classes and Business Logic

First we need references to services provided by the base framework:
{{{
private PositionService positionService;
private LookupService lookupService;
private TransactionService transactionService;

public MovServiceImpl(PositionService positionService, LookupService lookupService,
  TransactionService transactionService) {

	this.positionService = positionService;
	this.lookupService = lookupService;
	this.transactionService = transactionService;
}
}}}

These values will be auto injected on startup by the Springframework (based on applicationContext-mov.xml)

Next we need an Esper Subscriber to react onto market signals. This can be coded as a separate class or as an inner class within MovServiceImpl.java
{{{
public static class OpenPositionSubscriber {
	
  public void update(String strategyName, int securityId, BigDecimal currentValue) {
	

    MovServiceImpl movService = ((MovServiceImpl)    
      ServiceLocator.commonInstance().getService("movService"));

    movService.openPosition(strategyName, securityId, currentValue);
	
  }
}
}}}
The ServiceLocator will give as a reference to the “movService” (by the Springframework)

Finally we need a business method to instruct the base framework to open a position:
{{{
public void openPosition(String strategyName, int securityId, BigDecimal currentValue) {

  Strategy strategy = this.lookupService.getStrategyByNameFetched(strategyName);

  int qty = (int) (strategy.getAvailableFundsDouble() / currentValue.doubleValue());
	
  if (qty <= 0) return;

  OrderVO order = new OrderVO();
  order.setStrategyName(strategyName);
  order.setSecurityId(securityId);
  order.setRequestedQuantity(qty);
  order.setTransactionType(TransactionType.BUY);

  this.transactionService.executeTransaction(strategy.getName(), order);
	
 // if a position was open and exitValue
  Position position = this.lookupService.getPositionBySecurityAndStrategy(securityId, 
    strategyName);

  if (position != null && position.isOpen()) {
    
    double initialStopLoss = ConfigurationUtil.getStrategyConfig("MOV").   
      getDouble("initialStopLoss");

    double exitValue = initialStopLoss * currentValue.doubleValue();
    this.positionService.setExitValue(position.getId(), exitValue, true);
  }
}
}}}

The method contains the following steps:
 # We get a reference to the Strategy Entity by the LookpService. 
 # Then we evaluate the quantity that we want to purchase (in this case we use all available funds). 
 # Then we construct an Order Value Object (simple POJO object) containing the name of the strategy, the id of the security, the quantity and the transaction type.
 # The TransactionService will then carry out the transaction for us.
 # If a new position was created successfully, we want to set the initial stopLoss based on the current value and a constant initialStopLoss (which is configured inside conf-mov.properties)

== module-mov.epl ==

Next thing we have to develop is the Esper modul containing our statements. The module basically consists of the following three statements:

{{{
@Name('MOVING_AVERAGE')
insert into Indicator
select stat1.average - stat2.average as value
from Tick(security.isin = underlayingIsin).win:length(movLengthFast).stat:uni(currentValueDouble) as stat1, 
Tick(security.isin = underlayingIsin).win:length(movLengthSlow).stat:uni(currentValueDouble) as stat2
where stat2.datapoints = movLengthSlow;
}}}
This statement creates a Moving Average Indicator using the stat:uni Window

{{{
@Name('OPEN_POSITION')
@Tag(name='subscriber', value='com.algoTrader.service.mov.MovServiceImpl$OpenPositionSubscriber')
select
engineStrategy.name as strategyName, 
indexTick.security.id as underlayingid,
indexTick.currentValue as underlayingSpot
from pattern [every (indexTick=Tick(security.isin=underlayingIsin) -> indicator=Indicator)]
where indicator.value > 0
and prior(1, indicator.value) <= 0;
}}}
This statement calls the OpenPositionSubscriber whenever we have a crossover on the indicators. The Tag 'subscriber' is used to instruct the RuleService to attach the 'OpenPositionSubscriber' to this statement.

{{{
@Name('CREATE_EXIT_VALUE')
@Tag(name='subscriber', value='com.algoTrader.service.PositionServiceImpl$SetExitValueSubscriber')
select position.id as positionId,
exitValue.value as value
from Tick as tick,
method:LookupUtil.getPositions(tick.security) as position,
method:MovUtil.getExitValue(position.strategy.name, tick.security, tick.currentValueDouble) as exitValue
where exitValue.value > position.exitValue
and position.quantity != 0;
}}}
This statement is responsible to increase the trailing stop-loss whenever the underlaying moves up. It uses the LookupUtil (configured within esper-mov.cfg.xml) to get all currently open positions and the MovUtil to actually calculate the exitValue. The statement uses the configured 'SetExitValueSubscriber'. 

Note: The strategy does not have to close the position whenever the exitValue is reached. This is carried out automatically by the PositionService.

== conf-mov.properties ==

Now we need the configuration file, which contains the necessary parameters for the strategy:
{{{
underlayingIsin = CH0008616382
movLengthFast = 1000
movLengthSlow = 2000
initialStopLoss = 0.99
stopLoss = 0.97
}}}
In our case it is just the isin of the security that we are using, the length of our two moving average indicators and the initialStopLoss level as well as the trailing stopLoss level.

== esper-mov.cfg.xml ==

The esper configuration file consists of the following main parts:
{{{
<auto-import import-name="com.algoTrader.util.LookupUtil"/>
<auto-import import-name="com.algoTrader.service.mov.MovUtil"/>

<variable name="engineStrategy" type="com.algoTrader.entity.Strategy"/>
<variable name="underlayingIsin" type="String"/>
<variable name="movLengthFast" type="int"/>
<variable name="movLengthSlow" type="int"/>
}}}
First the two Util-Classes LookupUtil and MovUtil have to be configured. The necessary variables as well as their type are configured. 

Note: the actual values for the variables are taken from conf-mov.properties. 

The variable engineStrategy gets populated automatically by the RuleService and contains a reference to the Strategy-Entity we are using.

== DB table strategy ==

For this new Strategy we also need an entry in the DB table strategy with the following values:

|| *NAME* || *FAMILY* || *AUTO_ACTIVATE* || *ALLOCATION* || *MODULES* ||
|| MOV || MOV || true || 1.00 || mov-main ||

NAME and FAMILY are both set to the name of our strategy. 

AUTO_ACTIVATE means, that the strategy will be automatically run in simulation mode. By using this field, you can run several strategies in parallel to see how the interact.

ALLOCATION is the percentage of total assets, that will be allocated to this strategy. NOTE: the total of all allocations will need to add up to 100%. Example: If only 50% is allocated to our Strategy MOV, the reminder of 50% need to be allocated to the "BASE" strategy, which represents the trading framework itself.

NOTE:  The same strategy (eclipse project) can be run with different parameters (i.e. conf-mov1.properties & conf-mov2.properties). In this case NAME will be defined as MOV1 & MOV2 and FAMILY will be defined as MOV.

= Back Testing =

The System can be run in Back Testing / Simulation mode by setting the following parameter inside the file conf-base.properties or as a VM argument:

{{{simulation = true}}}

In simulation mode the trading framework as well as all strategies marked as autoActivate (in the database table strategy) are started inside the same JVM.

The symboles specified within the table watchers2watchlist are fed to the Esper engine instances using the {{{com.espertech.esperio.AdapterCoordinatorImpl}}} and {{{com.espertech.esperio.csv.CSVInputAdapter}}}. The CSV files containing the relevant tickdata should be placed in a subdirectory of {{{/AlgoTraderXXX/results/tickdata/}}}. This subdirectory has to be specified in the file conf-base.properties or as a VM argument as follows:

{{{dataSource.dataSet = current}}}

During simulation all Esper engine instances are set to use external timing. The AdapterCoordinator is responsible to create the necessary CurrentTimeEvents and send them to the Esper engine instances.

All orders are carried out in a simulated mode using the actual market prices supplied by the tick data.
At the end of each simulation, simulation results like the following are displayed:

{{{
execution time (min): 1.38 
dataSet: current 
netLiqValue: 1'152'940.16 
month-year:          Mai-10  Jun-10  Jul-10  Aug-10  Sep-10  Okt-10  
monthlyPerformance:  -5.40%  -0.30%  -6.77%   1.68%  11.76%  13.09%  
n=6 avgM=2.34% stdM=8.42% avgY=28.13% stdY=29.17% sharpRatio=0.959 
maxDrawDownM=6.77% bestMonthlyPerformance=13.09% maxDrawDown=24.84% maxDrawDownPeriod=140.00days colmarRatio=1.13
}}}

Before each simulation run, the database is reset to its original state. After the simulation the database modifications (mainly transactions and positions) are kept, in order to be able to perform further DB based analysis.

= UML Modelling and Code Generation =

Much of the system is modelled in UML. It is recommended to use MagicDraw for modelling (see [AlgoTraderDocumentation#Platform_requirements Platform_requirements])

To get familiar with the Code Generator AndroMDA the following 2 tutorials give a good overview:
 * http://www.andromda.org/docs/andromda-documentation/getting-started-java/index.html
 * http://www.andromda.org/docs/andromda-cartridges/andromda-spring-cartridge/howto.html

The actual UML Model is defined in the following xmi file:

 * /algotraderlight-mda/src/main/uml/algoTrader.xmi

= Tick Data Format = 

The Format of the Tick Data Files in use is based on a standard CSV Structure:

 * dateTime
 * last
 * lastDateTime
 * volBid
 * volAsk
 * bid
 * ask
 * vol
 * openIntrest
 * settlement

The first line within the file is the header row. DateTime and LastDateTime are of type long and represent milliseconds since 1970. 

Example:

|| *dateTime* || *last* || *lastDateTime* || *volBid* || *volAsk* || *bid* || *ask* || *vol* || *openIntrest* || *settlement* ||
|| 1299493621002 || 188 || 1299491709000 || 47 || 52 || 178.1 || 183.2 || 20 || 868 || 187  ||
|| 1299493680524 || 188 || 1299491709000 || 47 || 52 || 177.2 || 182.9 || 20 || 868 || 187 || 

<BR>
= Configuration  = 

Configuration is done using the [http://commons.apache.org/configuration Apache Commons Configuration Library].  For the trading framework as well as for each strategy one configuration file exists. The file conf-base.properties is the configuration file for the trading framework. It contains configuration values for the following areas:

 * Dabase Access
 * Simulation Parameters
 * Execution Parameters
 * Broker specific Parameters 

Using {{{org.apache.commons.configuration.CompositeConfiguration}}} configuration parameters can also be provided as a VM argument when starting up the system.

The configuration files are also used to define values for Esper variables. Because the Esper Variable system is strong typed, variables have to be configured within the corresponding Esper configuration files.

= Additional functionality of the proprietary full framework =
The AlgoTraderLight framework contains just the very basic core of the proprietary framework. The proprietary full Framework contains additional features in the following ares. 

 * Currency and Forex Handling (incl. Forex-Hedge and Rebalance)
 * Interest Rate and Dividend Handling
 * Modeled functionality of the share classes: Stocks, Bonds, Inrest Rate, Forex, Future & Stock Option
 * Stock Option and Future Pricing Engines (for Backtesting of Option and Future Based Strategies)
 * Runtime-Client using JMX & Swing (based on JConsole)
 * Historical Data Retrieval
 * Generic Broker Adapter
 * Rebalancing between Strategies
 * Separation of framework and strategies into separate VM’s (using RMI and Esper-Socket)
 * Automatic Parameter Optimization of Trading Strategies
 * Risk Management Features (Max Margin, Trailing Stop-Loss, Max Loss, Overnight CVaR, Max Leverage, Max monthly Draw-Down)

At a later time additional contributions in these areas are possible.