#summary Overall Documentation of the Framework AlgoTrader as well as instructions on how to build a strategy with it

<wiki:toc max_depth="2" />

= Introduction =

The Trading Framework AlgoTrader facilitates a minimum effort development of trading strategies based on Esper Query Language (EQL).

After backtesting, newly developed strategies can be tested in a live environment using Paper Trading Accounts. At the end of a thorough test procedure, the new strategy can be put into production. The following diagram shows the general procedure for developing new strategies:

http://cep-trader.googlecode.com/files/AlgoTrader-Strategy_Development_Process.gif

The system is developed by a Model Driven Architecture. All artifacts of the system are modeled in UML and generated into code by the [http://www.andromda.org/docs/index.html Framework AndroMDA].
The system does not provide a GUI Frontend. Instead it uses Java Management Extension (JMX) for management in runtime.

For Database Persistence the [http://www.hibernate.org/ Framework Hibernate] is used. All necessary information is recorded to the database in a statefull manner.

The system is also based on the Java Enterprise Framework [http://www.springsource.org/ Springframework], which enables a very clean Service Oriented Architecture.

= Architecture =

The System is basically composed of two layers.

The Trading Framework layer is the base for all strategies running on top of it. It is responsible for persistence to the database. It holds the connection to the Broker Interfaces to retrieve live market data as well as placing orders and tracking executions. The Trading Framework is also responsible for Risk Management, Portfolio Management, Performance Evaluation and Margining. For many of its tasks the Trading Framework uses a contained Esper Engine Instance.

On top of the Trading Framework any number of Strategies can be installed. Each strategy runs in its own process. Each Strategy contains its own Esper Engine Instance. A Strategy can use any type and number of Technical Indicators to evaluate trend and to retrieve market signals. Orders are delegated to the underlying Trading Framework for execution.

http://cep-trader.googlecode.com/files/AlgoTrader-Architecture_Layers.gif

= Platform requirements =

For development of new Strategies the following minimum Platform requirements exist:

|| *Software* || *URL* ||
|| Eclipse IDE || http://www.eclipse.org ||
|| Subversive SVN Client ||  http://www.eclipse.org/subversive ||
|| MySql Database || http://www.mysql.com ||
|| A database management tool (i.e. TOAD for MySql) || http://www.quest.com/toad-for-mysql  || 

<BR>
= Eclipse Projects =

The framework AlgoTrader consists of at least two Eclipse Projects:

 * AlgoTraderLight (the base trading framework)
 * AlgoTraderXXX (the strategy being developed)

AlgoTraderLight has the following structure:

|| *Directory* || *Description* ||
|| src || Contains manually created source files ||
|| target || Contains generated source files ||
|| classes || Contains compiled class files ||
|| lib || Contains Jar libraries ||
|| bin || Contains startup batch files ||
|| log || Contains log files ||
|| results || Contains files which are created (i.e. copy of retrieved HTML code) or imported (i.e. Tick Data) into the system ||
|| mda || Contains UML Model and AndroMDA configuration / customization files||
|| sql || Contains SQL scripts ||
|| doc || Contains documentation in Text-File Format ||

The Strategy Project AlgoTraderXXX has the following structure:

|| *Directory* || *Description* ||
|| src || Contains manually created source files ||
|| lib || Contains Jar libraries specifically needed by the strategy||
|| bin || Contains startup batch files ||
|| log || Contains log files ||
|| results || Contains mainly Tick Data Files ||

<BR>
= UML Model =

The UML Model in use by the system is shown here: [http://cep-trader.googlecode.com/files/AlgoTrader.pdf AlgoTrader UML Model]

= Java Packages =

The following table gives an overview of the provided java packages:

|| *Package* || *Description* ||
|| com.algoTrader || ServiceLocators ||
|| com.algoTrader.entity || Entities and corresponding Hibernate DataAccessObjects ||
|| com.algoTrader.service || Contains all Spring Services  ||
|| com.algoTrader.starter || Startup-Classes as well as a generic ServiceInvoker ||
|| com.algoTrader.subscriber || Esper Statement Subscribers ||
|| com.algoTrader.util || General Utility methods ||
|| com.algoTrader.util.io || CSV Adapters for Tick data as well as Tick data conversion functions ||

<BR>
= Esper Engine =

Individual Esper service engines exist inside the trading framework as well as within the strategies. 

Each of these can contain several modules. Modules specified with in the column Modules of the Table Strategy, are loaded automatically on startup.

Each strategy also contains its own Esper configuration file named esper-xxx.cfg.xml. These configuration files define settings like:

 * Event Types
 * Auto Import Classes & Packages
 * Custom Aggregation Functions
 * Variables
 * General Engine Settings

Esper Listeners and Subscribers are configured inside the modules using the following syntax:

{{{
@Name('REBALANCE_PORTFOLIO')
@Priority(2)
@Tag(name='listeners', value='com.algoTrader.listener.RebalancePortfolioListener')
select * from …
}}}

Listeners or Subscribers which correspond to a particular Service are commonly implemented as an inner class of the Service.

== Trading Framework Modules ==

The Trading Framework contains only one module called module-base.epl with Esper Statements to fulfill the following tasks:

 * Evaluation and Logging of the Portfolio Values at certain intervals
 * Position handling (i.e. close position when exit level is reached, etc.)
 * Evaluation of Performance Parameters (i.e. Sharpe Ratio, Calmar Ratio, Volatility, Draw-Down, etc.)
 * Margining

== Strategy Modules ==

Strategies are completely free in the definition of their Esper Statements. Examples of Statements used by strategies are:

 * Creation of technical indicators (i.e. Moving 
 * Average, Stochastic, MACD, etc.)
 * Creation of trade signals
 * Trend evaluation
 * Open / Close / Increase / Reduce Positions
 * Set Exit Values
 * Roll Positions (i.e. for Options and Futures)

= Database =

As described earlier the database MySql is used by the system, even though by using Hibernate, any supported database could be used.
 
To ensure referential integrity, foreign-key constraints are in place. The directory sql /AlgoTraderLight contains a script algotrader.sql to create the database.

= Strategy Development =

The following paragraph will give a short example based on a simple moving average strategy (with the Short Name MOV).

A strategy is based on the following minimum artifacts:

|| *Artifact* || *Description* ||
|| /src || Source-File Directory containing necessary Java-Classes for the Strategy ||
|| /lib || Directory containing Jar Files needed specifically for this Strategy ||
|| /module-mov.epl || Esper Module containing the necessary Esper Statements ||
|| /conf-mov.properties  || Contains parameters used by the strategy (i.e. Moving average durations etc.) ||
|| /esper-mov.cfg.xml || Contains event-types, imports, variables and general Esper settings ||
|| /beanRefFactorySimulation.xml || Spring Bean Reference Factory containing references to all Application Context Files ||
|| /applicationContext-mov.xml || Application Context File for the strategy, mainly containing autowire instructions ||
|| /results/tickdata/xxx || Directory containing Tick Data Files needed for Back Testing ||

== MovServiceImpl.java ==

This is the main Java-class containing Subscriber inner classes and Business Logic

First we need references to services provided by the base framework:
{{{
private PositionService positionService;
private LookupService lookupService;
private TransactionService transactionService;

public MovServiceImpl(PositionService positionService, LookupService lookupService,
  TransactionService transactionService) {

	this.positionService = positionService;
	this.lookupService = lookupService;
	this.transactionService = transactionService;
}
}}}

These values will be auto injected on startup by the Springframework (based on applicationContext-mov.xml)

Next we need an Esper Subscriber to react onto market signals. This can be coded as a separate class or as an inner class within MovServiceImpl.java
{{{
public static class OpenPositionSubscriber {
	
  public void update(String strategyName, int securityId, BigDecimal currentValue) {
	

    MovServiceImpl movService = ((MovServiceImpl)    
      ServiceLocator.commonInstance().getService("movService"));

    movService.openPosition(strategyName, securityId, currentValue);
	
  }
}
}}}
The ServiceLocator will give as a reference to the “movService” (by the Springframework)

Finally we need a business method to instruct the base framework to open a position:
{{{
public void openPosition(String strategyName, int securityId, BigDecimal currentValue) {

  Strategy strategy = this.lookupService.getStrategyByNameFetched(strategyName);

  int qty = (int) (strategy.getAvailableFundsDouble() / currentValue.doubleValue());
	
  if (qty <= 0) return;

  OrderVO order = new OrderVO();
  order.setStrategyName(strategyName);
  order.setSecurityId(securityId);
  order.setRequestedQuantity(qty);
  order.setTransactionType(TransactionType.BUY);

  this.transactionService.executeTransaction(strategy.getName(), order);
	
 // if a position was open and exitValue
  Position position = this.lookupService.getPositionBySecurityAndStrategy(securityId, 
    strategyName);

  if (position != null && position.isOpen()) {
    
    double initialStopLoss = ConfigurationUtil.getStrategyConfig("MOV").   
      getDouble("initialStopLoss");

    double exitValue = initialStopLoss * currentValue.doubleValue();
    this.positionService.setExitValue(position.getId(), exitValue, true);
  }
}
}}}

The method contains the following steps:
 # We get a reference to the Strategy Entity by the LookpService. 
 # Then we evaluate the quantity that we want to purchase (in this case we use all available funds). 
 # Then we construct an Order Value Object (simple POJO object) containing the name of the strategy, the id of the security, the quantity and the transaction type.
 # The TransactionService will then carry out the transaction for us.
 # If a new position was created successfully, we want to set the initial stopLoss based on the current value and a constant initialStopLoss (which is configured inside conf-mov.properties)

== module-mov.epl ==

Next thing we have to develop is the Esper modul containing our statements. The module basically consists of the following three statements:

{{{
@Name('MOVING_AVERAGE')
insert into Indicator
select stat1.average - stat2.average as value
from Tick(security.isin = underlayingIsin).win:length(movLengthFast).stat:uni(currentValueDouble) as stat1, 
Tick(security.isin = underlayingIsin).win:length(movLengthSlow).stat:uni(currentValueDouble) as stat2
where stat2.datapoints = movLengthSlow;
}}}
This statement creates a Moving Average Indicator using the stat:uni Window

{{{
@Name('OPEN_POSITION')
@Tag(name='subscriber', value='com.algoTrader.service.mov.MovServiceImpl$OpenPositionSubscriber')
select
engineStrategy.name as strategyName, 
indexTick.security.id as underlayingid,
indexTick.currentValue as underlayingSpot
from pattern [every (indexTick=Tick(security.isin=underlayingIsin) -> indicator=Indicator)]
where indicator.value > 0
and prior(1, indicator.value) <= 0;
}}}
This statement calls the OpenPositionSubscriber whenever we have a crossover on the indicators. The Tag 'subscriber' is used to instruct the RuleService to attach the 'OpenPositionSubscriber' to this statement.

{{{
@Name('CREATE_EXIT_VALUE')
@Tag(name='subscriber', value='com.algoTrader.service.PositionServiceImpl$SetExitValueSubscriber')
select position.id as positionId,
exitValue.value as value
from Tick as tick,
method:LookupUtil.getPositions(tick.security) as position,
method:MovUtil.getExitValue(position.strategy.name, tick.security, tick.currentValueDouble) as exitValue
where exitValue.value > position.exitValue
and position.quantity != 0;
}}}
This statement is responsible to increase the trailing stop-loss whenever the underlaying moves up. It uses the LookupUtil (configured within esper-mov.cfg.xml) to get all currently open positions and the MovUtil to actually calculate the exitValue. The statement uses the configured 'SetExitValueSubscriber'. 

Note: The strategy does not have to close the position whenever the exitValue is reached. This is carried out automatically by the PositionService.

== conf-mov.properties ==

Now we need the configuration file, which contains the necessary parameters for the strategy:
{{{
underlayingIsin = CH0008616382
movLengthFast = 1000
movLengthSlow = 2000
initialStopLoss = 0.99
stopLoss = 0.97
}}}
In our case it is just the isin of the security that we are using, the length of our two moving average indicators and the initialStopLoss level as well as the trailing stopLoss level.

== esper-mov.cfg.xml ==

The esper configuration file consists of the following main parts:
{{{
<auto-import import-name="com.algoTrader.util.LookupUtil"/>
<auto-import import-name="com.algoTrader.service.mov.MovUtil"/>

<variable name="engineStrategy" type="com.algoTrader.entity.Strategy"/>
<variable name="underlayingIsin" type="String"/>
<variable name="movLengthFast" type="int"/>
<variable name="movLengthSlow" type="int"/>
}}}
First the two Util-Classes LookupUtil and MovUtil have to be configured. The necessary variables as well as their type are configured. 

Note: the actual values for the variables are taken from conf-mov.properties. 

The variable engineStrategy gets populated automatically by the RuleService and contains a reference to the Strategy-Entity we are using.


= Back Testing =

The System can be run in Back Testing / Simulation mode by setting the following parameter inside the file conf-base.properties or as a VM argument:

{{{simulation = true}}}

In simulation mode the trading framework as well as all strategies marked as autoActivate (in the database table strategy) are started inside the same JVM.

The symboles specified within the table watchers2watchlist are fed to the Esper engine instances using the {{{com.espertech.esperio.AdapterCoordinatorImpl}}} and {{{com.espertech.esperio.csv.CSVInputAdapter}}}. The CSV files containing the relevant tickdata should be placed in a subdirectory of {{{/AlgoTraderXXX/results/tickdata/}}}. This subdirectory has to be specified in the file conf-base.properties or as a VM argument as follows:

{{{dataSource.dataSet = current}}}

During simulation all Esper engine instances are set to use external timing. The AdapterCoordinator is responsible to create the necessary CurrentTimeEvents and send them to the Esper engine instances.

All orders are carried out in a simulated mode using the actual market prices supplied by the tick data.
At the end of each simulation, simulation results like the following are displayed:

{{{
execution time (min): 1.38 
dataSet: current 
netLiqValue: 1'152'940.16 
month-year:          Mai-10  Jun-10  Jul-10  Aug-10  Sep-10  Okt-10  
monthlyPerformance:  -5.40%  -0.30%  -6.77%   1.68%  11.76%  13.09%  
n=6 avgM=2.34% stdM=8.42% avgY=28.13% stdY=29.17% sharpRatio=0.959 
maxDrawDownM=6.77% bestMonthlyPerformance=13.09% maxDrawDown=24.84% maxDrawDownPeriod=140.00days colmarRatio=1.13
}}}

Before each simulation run, the database is reset to its original state. After the simulation the database modifications (mainly transactions and positions) are kept, in order to be able to perform further DB based analysis.

= Tick Data Format = 

The Format of the Tick Data Files in use is based on a standard CSV Structure:

 * dateTime
 * last
 * lastDateTime
 * volBid
 * volAsk
 * bid
 * ask
 * vol
 * openIntrest
 * settlement

The first line within the file is the header row. DateTime and LastDateTime are of type long and represent milliseconds since 1970. 

Example:

|| *dateTime* || *last* || *lastDateTime* || *volBid* || *volAsk* || *bid* || *ask* || *vol* || *openIntrest* || *settlement* ||
|| 1299493621002 || 188 || 1299491709000 || 47 || 52 || 178.1 || 183.2 || 20 || 868 || 187  ||
|| 1299493680524 || 188 || 1299491709000 || 47 || 52 || 177.2 || 182.9 || 20 || 868 || 187 || 

<BR>
= Configuration  = 

Configuration is done using the [http://commons.apache.org/configuration Apache Commons Configuration Library].  For the trading framework as well as for each strategy one configuration file exists. The file conf-base.properties is the configuration file for the trading framework. It contains configuration values for the following areas:

 * Dabase Access
 * Simulation Parameters
 * Execution Parameters
 * Broker specific Parameters 

Using {{{org.apache.commons.configuration.CompositeConfiguration}}} configuration parameters can also be provided as a VM argument when starting up the system.

The configuration files are also used to define values for Esper variables. Because the Esper Variable system is strong typed, variables have to be configured within the corresponding Esper configuration files.